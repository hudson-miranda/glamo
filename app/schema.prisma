datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  email    String? @unique
  username String? @unique
  isAdmin  Boolean @default(false)

  // OpenSaaS payment fields
  paymentProcessorUserId        String?   @unique
  lemonSqueezyCustomerPortalUrl String? // You can delete this if you're not using Lemon Squeezy as your payments processor.
  subscriptionStatus            String? // 'active', 'cancel_at_period_end', 'past_due', 'deleted'
  subscriptionPlan              String? // 'hobby', 'pro'
  datePaid                      DateTime?
  credits                       Int       @default(3)

  // Glamo-specific fields
  name               String?
  phone              String?
  phone2             String?
  phoneType          String?
  phoneType2         String?
  address            String?
  addressNumber      String?
  complement         String?
  city               String?
  state              String?
  zipCode            String?
  birthDate          DateTime?
  activeSalonId      String?
  emailNotifications Boolean  @default(true) // User preference for email notifications
  deletedAt          DateTime?

  // OpenSaaS relations
  gptResponses        GptResponse[]
  contactFormMessages ContactFormMessage[]
  tasks               Task[]
  files               File[]

  // Glamo relations
  activeSalon              Salon?                 @relation("ActiveSalon", fields: [activeSalonId], references: [id], onDelete: Restrict)
  userSalons               UserSalon[]
  notifications            Notification[]
  logs                     Log[]
  createdServices          Service[]              @relation("ServiceCreatedBy")
  updatedServices          Service[]              @relation("ServiceUpdatedBy")
  createdProducts          Product[]              @relation("ProductCreatedBy")
  updatedProducts          Product[]              @relation("ProductUpdatedBy")
  createdPackages          Package[]              @relation("PackageCreatedBy")
  updatedPackages          Package[]              @relation("PackageUpdatedBy")
  professionalAppointments Appointment[]          @relation("ProfessionalAppointments")
  appointmentAssistants    AppointmentAssistant[]
  appointmentStatusLogs    AppointmentStatusLog[]
  availableTimeslots       AvailableTimeslot[]
  payments                 Payment[]
  handledSales             Sale[]                 @relation("EmployeeSales")
  createdSales             Sale[]                 @relation("SalesCreatedBy")
  updatedSales             Sale[]                 @relation("SalesUpdatedBy")
  clientCredits            ClientCredit[]
  cashSessionsOpened       CashRegisterSession[]  @relation("SessionOpenedBy")
  cashSessionsClosed       CashRegisterSession[]  @relation("SessionClosedBy")
  createdVouchers          Voucher[]
  sentInvites              SalonInvite[]
  employeeProfile          Employee[] // Relação com perfil de colaborador
  appointmentHistory       AppointmentHistory[]   @relation("AppointmentHistoryUser")
  
  // Client management relations
  clientUser               Client[]               @relation("ClientUser")
  clientNotes              ClientNote[]           @relation("ClientNoteAuthor")
  clientDocuments          ClientDocument[]       @relation("ClientDocumentUploader")
  
  // Phase 2: Communication & Engagement relations
  sentCommunications     CommunicationLog[]  @relation("CommunicationSender")
  createdCampaigns       MarketingCampaign[] @relation("CampaignCreator")
  createdSegments        ClientSegment[]     @relation("SegmentCreator")
  createdTemplates       CampaignTemplate[]  @relation("TemplateCreator")
  clientHistory          ClientHistory[]     @relation("ClientHistoryUser")
  
  // Phase 3: Loyalty & Advanced Features relations
  uploadedPhotos         ClientPhoto[]       @relation("PhotoUploader")
  createdAnamnesisForms  AnamnesisForm[]     @relation("AnamnesisFormCreator")
  filledAnamnesis        ClientAnamnesis[]   @relation("AnamnesisFilledBy")
}

model GptResponse {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  content String
}

model Task {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  userId String

  description String
  time        String  @default("1")
  isDone      Boolean @default(false)
}

model File {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id])
  userId String

  name      String
  type      String
  key       String
  uploadUrl String
}

model DailyStats {
  id   Int      @id @default(autoincrement())
  date DateTime @unique @default(now())

  totalViews                Int    @default(0)
  prevDayViewsChangePercent String @default("0")
  userCount                 Int    @default(0)
  paidUserCount             Int    @default(0)
  userDelta                 Int    @default(0)
  paidUserDelta             Int    @default(0)
  totalRevenue              Float  @default(0)
  totalProfit               Float  @default(0)

  sources PageViewSource[]
}

model PageViewSource {
  name String
  date DateTime @default(now())

  dailyStats   DailyStats? @relation(fields: [dailyStatsId], references: [id])
  dailyStatsId Int?

  visitors Int

  @@id([date, name])
}

model Logs {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  message String
  level   String
}

enum ContactMessageStatus {
  NEW
  READ
  REPLIED
  ARCHIVED
}

model ContactFormMessage {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Campos públicos (não requer login)
  name         String
  email        String
  message      String

  // Campo opcional para usuários autenticados
  userId       String?
  user         User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Status e gestão
  status       ContactMessageStatus @default(NEW)

  @@index([status])
  @@index([createdAt])
}

// ============================================================================
// GLAMO-SPECIFIC MODELS
// ============================================================================

// ============================================================================
// RBAC & Multi-Tenant Models
// ============================================================================

model Salon {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name           String
  description    String?
  cnpj           String?
  address        String?
  addressNumber  String?
  complement     String?
  city           String?
  state          String?
  zipCode        String?
  phoneType      String?
  phone          String?
  phoneType2     String?
  phone2         String?
  email          String?
  targetAudience String[]
  siteUrl        String?
  facebookUrl    String?
  instagramUrl   String?
  deletedAt      DateTime?

  activeUsers        User[]                @relation("ActiveSalon")
  userSalons         UserSalon[]
  roles              Role[]
  clients            Client[]
  services           Service[]
  products           Product[]
  packages           Package[]
  appointments       Appointment[]
  sales              Sale[]
  notifications      Notification[]
  availableTimeslots AvailableTimeslot[]
  serviceRooms       ServiceRoom[]
  clientCredits      ClientCredit[]
  cashSessions       CashRegisterSession[]
  productCategories  ProductCategory[]
  productBrands      ProductBrand[]
  suppliers          Supplier[]
  invitesSent        SalonInvite[]        @relation("InvitesSent")
  employees          Employee[] // Colaboradores do salão
  timeBlocks         TimeBlock[]
  waitingLists       WaitingList[]
  
  // Phase 2: Communication & Engagement relations
  communicationLogs  CommunicationLog[]
  marketingCampaigns MarketingCampaign[]
  clientSegments     ClientSegment[]
  campaignTemplates  CampaignTemplate[]
  bookingConfig      BookingConfig?
  
  // Phase 3: Loyalty & Advanced Features relations
  loyaltyPrograms       LoyaltyProgram[]
  clientLoyaltyBalances ClientLoyaltyBalance[]
  loyaltyTransactions   LoyaltyTransaction[]
  referralPrograms      ReferralProgram[]
  referrals             Referral[]
  clientPhotos          ClientPhoto[]
  anamnesisForms        AnamnesisForm[]
  clientAnamnesis       ClientAnamnesis[]
  clientMetrics         ClientMetrics[]
  salonAnalytics        SalonAnalytics[]
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

model SalonInvite {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId      String
  email        String
  roleId       String
  invitedBy    String
  status       InviteStatus @default(PENDING)
  expiresAt    DateTime
  acceptedAt   DateTime?
  rejectedAt   DateTime?

  salon        Salon        @relation("InvitesSent", fields: [salonId], references: [id], onDelete: Cascade)
  role         Role         @relation(fields: [roleId], references: [id], onDelete: Restrict)
  inviter      User         @relation(fields: [invitedBy], references: [id], onDelete: Restrict)

  @@unique([salonId, email])
  @@index([email])
  @@index([status])
}

model UserSalon {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  salonId   String
  isActive  Boolean   @default(true)
  deletedAt DateTime?

  user      User       @relation(fields: [userId], references: [id], onDelete: Restrict)
  salon     Salon      @relation(fields: [salonId], references: [id], onDelete: Restrict)
  userRoles UserRole[]

  @@unique([userId, salonId])
}

model Role {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId   String
  name      String
  deletedAt DateTime?

  salon           Salon            @relation(fields: [salonId], references: [id], onDelete: Restrict)
  rolePermissions RolePermission[]
  userRoles       UserRole[]
  invites         SalonInvite[]

  @@unique([salonId, name])
}

model Permission {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  name        String  @unique
  description String?

  rolePermissions RolePermission[]
}

model RolePermission {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  roleId       String
  permissionId String

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Restrict)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Restrict)

  @@unique([roleId, permissionId])
}

model UserRole {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  userSalonId String
  roleId      String

  userSalon UserSalon @relation(fields: [userSalonId], references: [id], onDelete: Restrict)
  role      Role      @relation(fields: [roleId], references: [id], onDelete: Restrict)

  @@unique([userSalonId, roleId])
}

// ============================================================================
// Audit & Notification Models
// ============================================================================

model Log {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  userId   String?
  entity   String
  entityId String
  action   String
  before   Json?
  after    Json?

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
}

enum NotificationChannel {
  INTERNAL
  PUSH
  EMAIL
  WHATSAPP
}

enum NotificationType {
  INFO
  WARNING
  ALERT
  SYSTEM
}

model Notification {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId          String
  salonId         String
  title           String
  message         String
  type            NotificationType    @default(INFO)
  channel         NotificationChannel @default(INTERNAL)
  systemGenerated Boolean             @default(false)
  read            Boolean             @default(false)

  user  User  @relation(fields: [userId], references: [id], onDelete: Restrict)
  salon Salon @relation(fields: [salonId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Client Models
// ============================================================================

model Client {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // === Core Identity ===
  salonId String
  userId  String? // Link to User for portal access

  // === Basic Information ===
  name  String
  email String?
  phone String?
  cpf   String?
  cnpj  String?

  // === Personal Details ===
  birthDate       DateTime?
  gender          Gender?
  profilePhotoUrl String?

  // === Address Information ===
  address       String?
  addressNumber String?
  complement    String?
  neighborhood  String?
  city          String?
  state         String?
  zipCode       String?
  country       String @default("BR")

  // === Contact Preferences ===
  preferredContactMethod ContactMethod @default(WHATSAPP)

  // === Marketing Consent (LGPD Compliance) ===
  emailMarketingConsent    Boolean   @default(false)
  smsMarketingConsent      Boolean   @default(false)
  whatsappMarketingConsent Boolean   @default(false)
  dataProcessingConsent    Boolean   @default(false)
  consentDate              DateTime?

  // === Client Status & Classification ===
  status         ClientStatus @default(ACTIVE)
  clientType     ClientType   @default(REGULAR)
  referralSource String?
  referralDetails String?

  // === Business Intelligence Fields ===
  firstVisitDate DateTime?
  lastVisitDate  DateTime?
  totalVisits    Int     @default(0)
  totalSpent     Float   @default(0)
  averageTicket  Float   @default(0)

  // === Additional Info ===
  instagramHandle String?
  observations    String? @db.Text
  deletedAt       DateTime?

  // === Relationships ===
  salon         Salon          @relation(fields: [salonId], references: [id], onDelete: Restrict)
  user          User?          @relation("ClientUser", fields: [userId], references: [id], onDelete: SetNull)
  appointments  Appointment[]
  sales         Sale[]
  clientCredits ClientCredit[]
  waitingLists  WaitingList[]
  tags          ClientTag[]
  notes         ClientNote[]
  documents     ClientDocument[]
  
  // Phase 2: Communication & Engagement relations
  communicationLogs CommunicationLog[]
  history       ClientHistory[]
  
  // Phase 3: Loyalty & Advanced Features relations
  loyaltyBalances   ClientLoyaltyBalance[]
  loyaltyTransactions LoyaltyTransaction[]
  referralsAsReferrer Referral[]  @relation("Referrer")
  referralsAsReferee  Referral[]  @relation("Referee")
  photos            ClientPhoto[]
  anamnesisSubmissions ClientAnamnesis[]
  metrics           ClientMetrics?

  @@unique([salonId, email])
  @@index([salonId, status])
  @@index([salonId, clientType])
  @@index([salonId, lastVisitDate])
  @@index([phone])
  @@index([email])
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
  PREFER_NOT_TO_SAY
}

enum ContactMethod {
  EMAIL
  PHONE
  WHATSAPP
  SMS
}

enum ClientStatus {
  ACTIVE   // Recent visits
  INACTIVE // No visit in 90+ days
  VIP      // High-value client
  BLOCKED  // Payment issues or banned
  PROSPECT // Never visited (from leads)
}

enum ClientType {
  REGULAR   // Standard client
  VIP       // VIP client
  CORPORATE // B2B client
  REFERRAL  // Came from referral
}

// Client Tags for segmentation
model ClientTag {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId String
  salonId  String
  name     String
  color    String? // Hex color for UI

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([salonId])
}

// Client Notes for observations and communication
model ClientNote {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId   String
  salonId    String
  userId     String // Who created the note
  title      String?
  content    String  @db.Text
  noteType   ClientNoteType @default(GENERAL)
  isAlert    Boolean        @default(false) // Show as alert/warning
  isInternal Boolean        @default(false) // Only visible to staff

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user   User   @relation("ClientNoteAuthor", fields: [userId], references: [id], onDelete: Restrict)

  @@index([clientId])
  @@index([salonId])
  @@index([userId])
}

enum ClientNoteType {
  GENERAL        // General observation
  SERVICE        // Service-related note
  PREFERENCE     // Client preference
  COMPLAINT      // Complaint or issue
  COMPLIMENT     // Positive feedback
  MEDICAL        // Medical information
  FINANCIAL      // Payment/financial note
  ADMINISTRATIVE // Administrative note
}

// Client Documents (anamnesis, contracts, etc.)
model ClientDocument {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId     String
  salonId      String
  userId       String // Who uploaded
  title        String
  description  String?
  documentType ClientDocumentType
  fileUrl      String // S3/Cloudinary URL
  fileName     String
  fileSize     Int // bytes
  mimeType     String
  deletedAt    DateTime?

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user   User   @relation("ClientDocumentUploader", fields: [userId], references: [id], onDelete: Restrict)

  @@index([clientId])
  @@index([salonId])
}

enum ClientDocumentType {
  ANAMNESIS      // Anamnesis form
  CONSENT        // Consent form
  CONTRACT       // Service contract
  PHOTO          // Before/after photo
  PRESCRIPTION   // Medical prescription
  ID_DOCUMENT    // ID copy
  OTHER          // Other documents
}

// Client History for audit trail
model ClientHistory {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  clientId String
  salonId  String
  userId   String? // Who made the change (null for system)
  action   ClientHistoryAction
  field    String? // Which field changed
  oldValue String? @db.Text
  newValue String? @db.Text
  metadata Json? // Additional context

  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user   User?  @relation("ClientHistoryUser", fields: [userId], references: [id], onDelete: SetNull)

  @@index([clientId])
  @@index([salonId])
  @@index([createdAt])
}

enum ClientHistoryAction {
  CREATED           // Client created
  UPDATED           // Client updated
  STATUS_CHANGED    // Status changed
  NOTE_ADDED        // Note added
  TAG_ADDED         // Tag added
  TAG_REMOVED       // Tag removed
  DOCUMENT_UPLOADED // Document uploaded
  APPOINTMENT_BOOKED // Appointment created
  APPOINTMENT_CANCELLED // Appointment cancelled
  SALE_COMPLETED    // Sale completed
  CREDIT_ADDED      // Credit added
  CONSENT_UPDATED   // Marketing consent changed
}

model ClientCredit {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId       String
  professionalId String?
  salonId        String
  amount         Float
  origin         String
  paymentMethod  String?
  date           DateTime @default(now())
  notes          String?

  client         Client          @relation(fields: [clientId], references: [id], onDelete: Restrict)
  professional   User?           @relation(fields: [professionalId], references: [id], onDelete: SetNull)
  salon          Salon           @relation(fields: [salonId], references: [id], onDelete: Restrict)
  creditPayments CreditPayment[]
}

// ============================================================================
// Service Models
// ============================================================================

model ServiceRoom {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId     String
  name        String
  description String?
  deletedAt   DateTime?

  salon    Salon     @relation(fields: [salonId], references: [id], onDelete: Restrict)
  services Service[]
}

enum ValueType {
  FIXED
  PERCENT
}

model Service {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId                    String
  createdByUserId            String
  updatedByUserId            String?
  serviceRoomId              String?
  name                       String
  description                String?
  hasVariants                Boolean   @default(false)
  duration                   Int
  price                      Float
  costValue                  Float     @default(0)
  costValueType              ValueType @default(FIXED)
  nonCommissionableValue     Float     @default(0)
  nonCommissionableValueType ValueType @default(FIXED)
  cardColor                  String?
  deletedAt                  DateTime?

  salon               Salon                @relation(fields: [salonId], references: [id], onDelete: Restrict)
  createdBy           User                 @relation("ServiceCreatedBy", fields: [createdByUserId], references: [id], onDelete: Restrict)
  updatedBy           User?                @relation("ServiceUpdatedBy", fields: [updatedByUserId], references: [id], onDelete: SetNull)
  serviceRoom         ServiceRoom?         @relation(fields: [serviceRoomId], references: [id], onDelete: SetNull)
  variants            ServiceVariant[]
  categories          ServiceCategory[]
  commissionConfig    CommissionConfig?
  appointmentServices AppointmentService[]
  saleServices        SaleService[]
  packageServices     PackageService[]
  employeeServices    EmployeeService[] // Relação com colaboradores que podem executar este serviço
}

model ServiceVariant {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  serviceId                  String
  name                       String
  description                String?
  duration                   Int
  price                      Float
  costValue                  Float     @default(0)
  costValueType              ValueType @default(FIXED)
  nonCommissionableValue     Float     @default(0)
  nonCommissionableValueType ValueType @default(FIXED)
  deletedAt                  DateTime?

  service             Service              @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  appointmentServices AppointmentService[]
  saleServices        SaleService[]
}

model ServiceCategory {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  serviceId String
  name      String
  color     String?

  service Service @relation(fields: [serviceId], references: [id], onDelete: Restrict)
}

model CommissionConfig {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  serviceId                        String    @unique
  commissionType                   String
  baseValueType                    ValueType
  baseValue                        Float
  deductAssistantsFromProfessional Boolean   @default(false)
  soloValue                        Float
  soloValueType                    ValueType
  withAssistantValue               Float
  withAssistantValueType           ValueType
  asAssistantValue                 Float
  asAssistantValueType             ValueType

  service Service @relation(fields: [serviceId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Appointment Models
// ============================================================================

model AvailableTimeslot {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId      String
  salonId     String
  weekday     String
  startTime   String
  endTime     String
  isAvailable Boolean @default(true)

  user  User  @relation(fields: [userId], references: [id], onDelete: Restrict)
  salon Salon @relation(fields: [salonId], references: [id], onDelete: Restrict)
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  IN_SERVICE
  DONE
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PARTIAL
  PAID
  REFUNDED
}

model Appointment {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId        String
  clientId       String
  professionalId String
  employeeId     String? // Opcional: referência ao Employee (se o profissional for um colaborador cadastrado)
  voucherId      String?
  startAt        DateTime
  endAt          DateTime
  status         AppointmentStatus @default(PENDING)
  paymentStatus  PaymentStatus     @default(PENDING)
  notes          String?
  
  // Enhanced scheduling fields
  bookedOnline      Boolean @default(false)
  bookingSource     String? // STAFF, CLIENT_ONLINE, CLIENT_PHONE, WALK_IN
  confirmationCode  String? @unique
  
  // Client confirmation
  clientConfirmed   Boolean  @default(false)
  clientConfirmedAt DateTime?
  
  // Cancellation tracking
  cancelledBy       String? // CLIENT, STAFF, SYSTEM
  cancellationReason String?
  cancellationFee   Float?  @default(0)
  
  // Rescheduling tracking
  rescheduleCount       Int     @default(0)
  originalAppointmentId String?
  
  // No-show tracking
  isNoShow   Boolean @default(false)
  noShowFee  Float?
  
  // Pricing
  totalPrice     Float?
  discountAmount Float?  @default(0)
  finalPrice     Float?
  
  deletedAt DateTime?

  salon        Salon                  @relation(fields: [salonId], references: [id], onDelete: Restrict)
  client       Client                 @relation(fields: [clientId], references: [id], onDelete: Restrict)
  professional User                   @relation("ProfessionalAppointments", fields: [professionalId], references: [id], onDelete: Restrict)
  employee     Employee?              @relation("EmployeeAppointments", fields: [employeeId], references: [id], onDelete: SetNull)
  voucher      Voucher?               @relation(fields: [voucherId], references: [id], onDelete: SetNull)
  services     AppointmentService[]
  assistants   AppointmentAssistant[]
  repetition   AppointmentRepetition?
  statusLogs   AppointmentStatusLog[]
  reminders    AppointmentReminder[]
  history      AppointmentHistory[]
  
  // Phase 3: Loyalty & Advanced Features relations
  photos       ClientPhoto[]
  anamnesis    ClientAnamnesis[]
  
  @@index([salonId, startAt])
  @@index([employeeId, startAt])
  @@index([status])
  @@index([confirmationCode])
}

model AppointmentService {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  appointmentId  String
  serviceId      String
  variantId      String?
  customPrice    Float?
  customDuration Int?
  discount       Float   @default(0)

  appointment Appointment     @relation(fields: [appointmentId], references: [id], onDelete: Restrict)
  service     Service         @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  variant     ServiceVariant? @relation(fields: [variantId], references: [id], onDelete: SetNull)
}

model AppointmentAssistant {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  appointmentId   String
  assistantUserId String

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Restrict)
  assistant   User        @relation(fields: [assistantUserId], references: [id], onDelete: Restrict)

  @@unique([appointmentId, assistantUserId])
}

model AppointmentRepetition {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  appointmentId String    @unique
  rule          String
  repeatUntil   DateTime?

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Restrict)
}

model AppointmentStatusLog {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  appointmentId   String
  updatedByUserId String
  fromStatus      AppointmentStatus?
  toStatus        AppointmentStatus
  changedAt       DateTime           @default(now())

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Restrict)
  updatedBy   User        @relation(fields: [updatedByUserId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Product & Inventory Models
// ============================================================================

model ProductCategory {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId     String
  name        String
  description String?
  deletedAt   DateTime?

  salon    Salon     @relation(fields: [salonId], references: [id], onDelete: Restrict)
  products Product[]
}

model ProductBrand {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId     String
  name        String
  description String?
  deletedAt   DateTime?

  salon    Salon     @relation(fields: [salonId], references: [id], onDelete: Restrict)
  products Product[]
}

model Supplier {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId       String
  name          String
  description   String?
  email         String?
  phoneType     String?
  phone         String?
  phoneType2    String?
  phone2        String?
  contactName   String?
  cnpj          String?
  address       String?
  addressNumber String?
  complement    String?
  city          String?
  state         String?
  zipCode       String?
  deletedAt     DateTime?

  salon    Salon     @relation(fields: [salonId], references: [id], onDelete: Restrict)
  products Product[]
}

model Product {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId             String
  categoryId          String?
  brandId             String?
  supplierId          String?
  createdByUserId     String
  updatedByUserId     String?
  name                String
  costPrice           Float
  salePrice           Float
  stockQuantity       Int       @default(0)
  initialStock        Int       @default(0)
  minimumStock        Int       @default(0)
  saleCommissionValue Float     @default(0)
  saleCommissionType  ValueType @default(FIXED)
  unitOfMeasure       String?
  quantityPerPackage  Int       @default(1)
  barcode             String?
  sku                 String?
  deletedAt           DateTime?

  salon        Salon            @relation(fields: [salonId], references: [id], onDelete: Restrict)
  category     ProductCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  brand        ProductBrand?    @relation(fields: [brandId], references: [id], onDelete: SetNull)
  supplier     Supplier?        @relation(fields: [supplierId], references: [id], onDelete: SetNull)
  createdBy    User             @relation("ProductCreatedBy", fields: [createdByUserId], references: [id], onDelete: Restrict)
  updatedBy    User?            @relation("ProductUpdatedBy", fields: [updatedByUserId], references: [id], onDelete: SetNull)
  stockRecords StockRecord[]
  saleProducts SaleProduct[]
}

enum MovementType {
  IN
  OUT
  ADJUST
}

model StockRecord {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  productId        String
  movementType     MovementType
  quantity         Int
  reason           String?
  previousQuantity Int
  finalQuantity    Int

  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Package Models
// ============================================================================

model Package {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId         String
  createdByUserId String
  updatedByUserId String?
  name            String
  description     String?
  totalPrice      Float
  validityType    String?
  validityValue   Int?
  isArchived      Boolean   @default(false)
  deletedAt       DateTime?

  salon           Salon            @relation(fields: [salonId], references: [id], onDelete: Restrict)
  createdBy       User             @relation("PackageCreatedBy", fields: [createdByUserId], references: [id], onDelete: Restrict)
  updatedBy       User?            @relation("PackageUpdatedBy", fields: [updatedByUserId], references: [id], onDelete: SetNull)
  packageServices PackageService[]
  salePackages    SalePackage[]
}

model PackageService {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  packageId       String
  serviceId       String
  customUnitPrice Float?
  quantity        Int    @default(1)

  package Package @relation(fields: [packageId], references: [id], onDelete: Restrict)
  service Service @relation(fields: [serviceId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Voucher Models
// ============================================================================

model Voucher {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId             String
  code               String    @unique
  discountValue      Float?
  discountPercentage Float?
  discountType       String
  applicableTo       String?
  applicableEntityId String?
  usageLimit         Int?
  usedCount          Int       @default(0)
  expirationDate     DateTime?
  issueDate          DateTime  @default(now())
  status             String
  deletedAt          DateTime?

  user         User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  appointments Appointment[]
  sales        Sale[]
}

// ============================================================================
// Sales & Payment Models
// ============================================================================

enum SaleStatus {
  OPEN
  PAID
  CANCELLED
}

model Sale {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId         String
  clientId        String?
  employeeId      String
  voucherId       String?
  createdByUserId String
  updatedByUserId String?
  originalTotal   Float
  discountTotal   Float      @default(0)
  finalTotal      Float
  status          SaleStatus @default(OPEN)
  deletedAt       DateTime?

  salon        Salon         @relation(fields: [salonId], references: [id], onDelete: Restrict)
  client       Client?       @relation(fields: [clientId], references: [id], onDelete: SetNull)
  employee     User          @relation("EmployeeSales", fields: [employeeId], references: [id], onDelete: Restrict)
  voucher      Voucher?      @relation(fields: [voucherId], references: [id], onDelete: SetNull)
  createdBy    User          @relation("SalesCreatedBy", fields: [createdByUserId], references: [id], onDelete: Restrict)
  updatedBy    User?         @relation("SalesUpdatedBy", fields: [updatedByUserId], references: [id], onDelete: SetNull)
  saleServices SaleService[]
  saleProducts SaleProduct[]
  salePackages SalePackage[]
  payments     Payment[]
}

model SaleService {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  saleId     String
  serviceId  String
  variantId  String?
  unitPrice  Float
  discount   Float   @default(0)
  finalPrice Float

  sale    Sale            @relation(fields: [saleId], references: [id], onDelete: Restrict)
  service Service         @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  variant ServiceVariant? @relation(fields: [variantId], references: [id], onDelete: SetNull)
}

model SaleProduct {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  saleId     String
  productId  String
  quantity   Int
  unitPrice  Float
  discount   Float  @default(0)
  finalPrice Float

  sale    Sale    @relation(fields: [saleId], references: [id], onDelete: Restrict)
  product Product @relation(fields: [productId], references: [id], onDelete: Restrict)
}

model SalePackage {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  saleId        String
  packageId     String
  originalPrice Float
  discount      Float  @default(0)
  finalPrice    Float

  sale    Sale    @relation(fields: [saleId], references: [id], onDelete: Restrict)
  package Package @relation(fields: [packageId], references: [id], onDelete: Restrict)
}

enum PaymentMethodType {
  CASH
  CARD
  PIX
  ONLINE
  CREDIT_CLIENT
}

model PaymentMethod {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  name     String
  type     PaymentMethodType
  isOnline Boolean           @default(false)

  payments Payment[]
}

model Payment {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  userId   String
  saleId   String
  methodId String
  amount   Float
  status   PaymentStatus @default(PENDING)

  user           User            @relation(fields: [userId], references: [id], onDelete: Restrict)
  sale           Sale            @relation(fields: [saleId], references: [id], onDelete: Restrict)
  method         PaymentMethod   @relation(fields: [methodId], references: [id], onDelete: Restrict)
  creditPayments CreditPayment[]
}

model CreditPayment {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  paymentId  String
  creditId   String
  amountUsed Float

  payment Payment      @relation(fields: [paymentId], references: [id], onDelete: Restrict)
  credit  ClientCredit @relation(fields: [creditId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Cash Register Models
// ============================================================================

model CashRegisterSession {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId        String
  openedBy       String
  openedAt       DateTime  @default(now())
  openingBalance Float
  closedBy       String?
  closedAt       DateTime?
  closingBalance Float?
  reconciled     Boolean   @default(false)

  salon     Salon          @relation(fields: [salonId], references: [id], onDelete: Restrict)
  opener    User           @relation("SessionOpenedBy", fields: [openedBy], references: [id], onDelete: Restrict)
  closer    User?          @relation("SessionClosedBy", fields: [closedBy], references: [id], onDelete: SetNull)
  movements CashMovement[]
}

enum CashMovementType {
  PAYMENT
  SANGRIA
  SUPRIMENTO
}

model CashMovement {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  sessionId String
  type      CashMovementType
  amount    Float
  notes     String?

  session CashRegisterSession @relation(fields: [sessionId], references: [id], onDelete: Restrict)
}

// ============================================================================
// Advanced Scheduling Models
// ============================================================================

// Time blocks for employee unavailability (vacation, breaks, etc.)
model TimeBlock {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId    String
  employeeId String?  // null = salon-wide block (holiday, maintenance)
  startTime  DateTime
  endTime    DateTime
  reason     String?
  type       TimeBlockType @default(CUSTOM)
  
  // Recurrence support
  isRecurring      Boolean  @default(false)
  recurrenceRule   String?  // RRULE format
  recurrenceEndDate DateTime?
  parentBlockId    String?  // For recurring blocks
  
  deletedAt  DateTime?

  salon    Salon     @relation(fields: [salonId], references: [id], onDelete: Restrict)
  employee Employee? @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  
  @@index([salonId])
  @@index([employeeId])
  @@index([startTime, endTime])
}

enum TimeBlockType {
  VACATION
  SICK_LEAVE
  BREAK
  LUNCH
  MAINTENANCE
  HOLIDAY
  PERSONAL
  CUSTOM
}

// Waiting list for unavailable appointment slots
model WaitingList {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId        String
  clientId       String
  employeeId     String?  // Preferred employee
  serviceIds     String[] // Desired services
  
  // Preferred time preferences
  preferredDate      DateTime?
  preferredStartTime String?   // HH:mm format
  preferredEndTime   String?   // HH:mm format
  flexibleTiming     Boolean   @default(true)
  
  // Status tracking
  status       WaitingListStatus @default(WAITING)
  notifiedAt   DateTime?
  expiresAt    DateTime?
  priority     Int               @default(0) // Higher = more priority
  
  notes     String?
  deletedAt DateTime?

  salon    Salon     @relation(fields: [salonId], references: [id], onDelete: Restrict)
  client   Client    @relation(fields: [clientId], references: [id], onDelete: Restrict)
  employee Employee? @relation(fields: [employeeId], references: [id], onDelete: SetNull)
  
  @@index([salonId, status])
  @@index([clientId])
  @@index([employeeId])
}

enum WaitingListStatus {
  WAITING
  NOTIFIED
  ACCEPTED
  EXPIRED
  CANCELLED
}

// Appointment reminders tracking
model AppointmentReminder {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  appointmentId String
  type          ReminderType
  channel       NotificationChannel
  scheduledFor  DateTime
  sentAt        DateTime?
  status        ReminderStatus     @default(PENDING)
  
  // Message content
  subject       String?
  message       String  @db.Text
  recipient     String  // Phone or email
  
  // External tracking
  externalId    String?
  failureReason String?
  
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  
  @@index([appointmentId])
  @@index([scheduledFor, status])
}

enum ReminderType {
  CONFIRMATION
  REMINDER_24H
  REMINDER_2H
  REMINDER_1H
  REMINDER_CUSTOM
}

enum ReminderStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

// Complete audit trail for appointment changes
model AppointmentHistory {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  appointmentId String
  userId        String?
  action        AppointmentAction
  field         String?
  oldValue      String?
  newValue      String?
  notes         String?

  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  user        User?       @relation("AppointmentHistoryUser", fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([appointmentId])
  @@index([createdAt])
}

enum AppointmentAction {
  CREATED
  UPDATED
  CANCELLED
  RESCHEDULED
  CONFIRMED
  COMPLETED
  NO_SHOW
  STATUS_CHANGED
}

// Booking configuration for salon
model BookingConfig {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  salonId String @unique
  
  // Booking window
  minAdvanceHours   Int @default(2)   // Minimum advance booking
  maxAdvanceDays    Int @default(90)  // Maximum advance booking
  
  // Cancellation policy
  freeCancellationHours Int @default(24)
  lateCancellationHours Int @default(12)
  lateCancellationFee   Int @default(50) // Percentage
  
  // Rescheduling policy
  allowRescheduling    Boolean @default(true)
  maxRescheduleCount   Int     @default(2)
  minRescheduleHours   Int     @default(24)
  
  // No-show policy
  noShowFeePercent     Int     @default(100)
  autoMarkNoShowMinutes Int    @default(15)
  
  // General settings
  allowSameDayBooking  Boolean @default(true)
  slotInterval         Int     @default(15) // Minutes
  bufferTimeMinutes    Int     @default(0)
  
  // Reminders
  enableReminders      Boolean @default(true)
  reminder24h          Boolean @default(true)
  reminder2h           Boolean @default(true)
  reminderChannels     String[] // SMS, EMAIL, WHATSAPP
  
  salon Salon @relation(fields: [salonId], references: [id], onDelete: Cascade)
}

// ============================================================================
// Employee Models
// ============================================================================

model Employee {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relacionamentos principais
  salonId String
  userId  String? // Opcional - apenas se o colaborador tiver acesso ao sistema

  // Dados pessoais
  name       String
  email      String?
  phone      String?
  phone2     String?
  instagram  String?
  birthDate  DateTime?
  color      String? // Cor para exibição na agenda (hex color)

  // Documentos
  cpf             String?
  rg              String?
  rgIssuingBody   String? // Órgão Expedidor

  // Dados bancários
  pixKey        String?
  bankName      String?
  bankAgency    String?
  bankAccount   String?
  bankDigit     String?
  accountType   String? // Corrente, Poupança
  personType    String? // Pessoa Física, Pessoa Jurídica
  companyName   String? // Razão Social (se PJ)
  cnpj          String? // CNPJ (se PJ)

  // Endereço
  address       String?
  addressNumber String?
  complement    String?
  neighborhood  String? // Bairro
  city          String?
  state         String?
  zipCode       String?

  // Configurações profissionais
  position    String? // Cargo/Função (relacionado com Role)
  permissions String[] // Array de permissionIds temporário até termos relação formal

  // Configurações de comissão e gorjeta (mockup)
  commissionType           String? // Tipo de comissão
  commissionValue          Float?  // Valor ou percentual de comissão
  tipRule                  String? // Regra de gorjeta
  canReceiveTips           Boolean @default(true)
  tipsOnlyFromAppointments Boolean @default(true)

  // Controle
  isActive  Boolean   @default(true)
  deletedAt DateTime?

  // Relações
  salon            Salon                @relation(fields: [salonId], references: [id], onDelete: Restrict)
  user             User?                @relation(fields: [userId], references: [id], onDelete: SetNull)
  schedules        EmployeeSchedule[]
  serviceAssignments EmployeeService[]
  appointments     Appointment[]        @relation("EmployeeAppointments")
  timeBlocks       TimeBlock[]
  waitingLists     WaitingList[]

  @@index([salonId])
  @@index([userId])
  @@index([email])
}

model EmployeeSchedule {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  employeeId String
  dayOfWeek  Int // 0 = Domingo, 1 = Segunda, ..., 6 = Sábado
  
  // Período da manhã/tarde/noite
  startTime String // Formato HH:mm
  endTime   String // Formato HH:mm

  // Permite múltiplos períodos no mesmo dia
  isActive Boolean @default(true)

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId])
  @@index([dayOfWeek])
}

// Tabela de relação entre Employee e Service (quais serviços cada profissional pode realizar)
model EmployeeService {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  employeeId String
  serviceId  String

  // Configurações específicas do serviço para este profissional
  customDuration Int? // Duração personalizada (em minutos)
  customPrice    Float? // Preço personalizado
  commission     Float? // Comissão específica para este serviço

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  service  Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([employeeId, serviceId])
  @@index([employeeId])
  @@index([serviceId])
}

// ============================================================================
// Client Management Phase 2 - Communication & Engagement
// ============================================================================

// Communication Log - Track all client communications
model CommunicationLog {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clientId String
  salonId  String
  userId   String? // User who sent (null for automated)

  type              CommunicationType
  channel           CommunicationChannel
  direction         CommunicationDirection
  
  subject           String?
  message           String            @db.Text
  recipientPhone    String?
  recipientEmail    String?
  
  status            CommunicationStatus @default(PENDING)
  sentAt            DateTime?
  deliveredAt       DateTime?
  readAt            DateTime?
  clickedAt         DateTime?
  
  failureReason     String?           @db.Text
  externalId        String?           // Provider's message ID (Twilio, SendGrid, etc.)
  cost              Float?            // Communication cost
  
  // Link to campaign if part of one
  campaignId        String?
  
  metadata          Json?             // Additional data (template vars, etc.)
  
  client   Client             @relation(fields: [clientId], references: [id], onDelete: Cascade)
  salon    Salon              @relation(fields: [salonId], references: [id], onDelete: Cascade)
  user     User?              @relation("CommunicationSender", fields: [userId], references: [id], onDelete: SetNull)
  campaign MarketingCampaign? @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  
  @@index([clientId, createdAt])
  @@index([salonId, type, createdAt])
  @@index([status])
  @@index([campaignId])
  @@index([externalId])
}

enum CommunicationType {
  APPOINTMENT_REMINDER
  APPOINTMENT_CONFIRMATION
  APPOINTMENT_CANCELLED
  BIRTHDAY_GREETING
  PROMOTIONAL_CAMPAIGN
  REACTIVATION_CAMPAIGN
  FEEDBACK_REQUEST
  LOYALTY_REWARD_NOTIFICATION
  CUSTOM_MESSAGE
  FOLLOW_UP
  THANK_YOU
}

enum CommunicationChannel {
  EMAIL
  SMS
  WHATSAPP
  PUSH_NOTIFICATION
  IN_APP
}

enum CommunicationDirection {
  OUTBOUND  // Salon to client
  INBOUND   // Client to salon
}

enum CommunicationStatus {
  PENDING
  QUEUED
  SENT
  DELIVERED
  READ
  CLICKED
  FAILED
  BOUNCED
  UNSUBSCRIBED
}

// Marketing Campaign - Campaign management
model MarketingCampaign {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  salonId String
  
  name        String
  description String?        @db.Text
  type        CampaignType
  status      CampaignStatus @default(DRAFT)
  
  // Targeting
  segmentId       String?    // Client segment ID
  targetClientIds String[]   // Or specific client IDs
  
  // Content
  subject         String?
  messageTemplate String     @db.Text
  channel         CommunicationChannel
  
  // Scheduling
  scheduledAt DateTime?
  sentAt      DateTime?
  completedAt DateTime?
  
  // Metrics
  targetCount     Int @default(0)
  sentCount       Int @default(0)
  deliveredCount  Int @default(0)
  openCount       Int @default(0)
  clickCount      Int @default(0)
  conversionCount Int @default(0)
  
  // Budget
  estimatedCost Float?
  actualCost    Float?
  
  createdBy String
  
  salon         Salon              @relation(fields: [salonId], references: [id], onDelete: Cascade)
  creator       User               @relation("CampaignCreator", fields: [createdBy], references: [id], onDelete: Restrict)
  segment       ClientSegment?     @relation(fields: [segmentId], references: [id], onDelete: SetNull)
  communications CommunicationLog[]
  
  @@index([salonId, status])
  @@index([salonId, type])
  @@index([scheduledAt])
}

enum CampaignType {
  BIRTHDAY
  REACTIVATION
  PROMOTIONAL
  ANNOUNCEMENT
  FEEDBACK_REQUEST
  CUSTOM
  APPOINTMENT_REMINDER
  FOLLOW_UP
}

enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  COMPLETED
  CANCELLED
  FAILED
  PAUSED
}

// Client Segment - Dynamic client groups for targeting
model ClientSegment {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  salonId String
  
  name        String
  description String? @db.Text
  
  // Segment Criteria (JSON with rules)
  criteria Json
  
  // Cached Results
  clientCount      Int       @default(0)
  lastCalculatedAt DateTime?
  
  isActive  Boolean @default(true)
  createdBy String
  
  salon     Salon               @relation(fields: [salonId], references: [id], onDelete: Cascade)
  creator   User                @relation("SegmentCreator", fields: [createdBy], references: [id], onDelete: Restrict)
  campaigns MarketingCampaign[]
  
  @@index([salonId, isActive])
}

// Campaign Template - Reusable campaign templates
model CampaignTemplate {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  salonId String?   // null = system template, available to all
  
  name        String
  description String?        @db.Text
  type        CampaignType
  channel     CommunicationChannel
  
  subject         String?
  messageTemplate String @db.Text
  
  // Placeholders documentation
  placeholders    String[] // ["{{clientName}}", "{{salonName}}", etc.]
  
  isActive  Boolean @default(true)
  isSystem  Boolean @default(false) // System templates can't be edited
  usageCount Int    @default(0)
  
  createdBy String?
  
  salon   Salon? @relation(fields: [salonId], references: [id], onDelete: Cascade)
  creator User?  @relation("TemplateCreator", fields: [createdBy], references: [id], onDelete: SetNull)
  
  @@index([salonId])
  @@index([type])
}

// ============================================================================
// Client Management Phase 3 - Loyalty & Advanced Features
// ============================================================================

// ============================================================================
// Loyalty Program Models
// ============================================================================

// Loyalty Program Configuration
model LoyaltyProgram {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  salonId String
  
  name        String
  description String? @db.Text
  isActive    Boolean @default(true)
  
  // Cashback Configuration
  cashbackEnabled       Boolean @default(true)
  cashbackType          CashbackType @default(PERCENTAGE)
  cashbackValue         Float // Percentage (e.g., 5.0 = 5%) or fixed amount
  minPurchaseForCashback Float   @default(0)
  maxCashbackPerTransaction Float?
  
  // Redemption Rules
  minBalanceToRedeem    Float   @default(0)
  maxRedemptionPercentage Int   @default(100) // Max % of purchase that can be paid with cashback
  cashbackExpiryDays    Int?    // Days until cashback expires (null = never)
  
  // Points System (Optional - for future enhancement)
  pointsEnabled         Boolean @default(false)
  pointsPerReal         Float   @default(1) // Points earned per R$1
  reaisPerPoint         Float   @default(0.1) // R$ value per point (10 cents)
  
  // VIP Tiers
  vipTiersEnabled       Boolean @default(false)
  
  deletedAt DateTime?
  
  salon      Salon                  @relation(fields: [salonId], references: [id], onDelete: Cascade)
  tiers      LoyaltyTier[]
  balances   ClientLoyaltyBalance[]
  transactions LoyaltyTransaction[]
  
  @@index([salonId, isActive])
}

enum CashbackType {
  PERCENTAGE
  FIXED
  POINTS
}

// VIP Tiers Configuration
model LoyaltyTier {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  programId String
  
  name        String
  description String? @db.Text
  color       String? // Hex color for UI
  icon        String? // Icon name or emoji
  
  // Tier Requirements
  minTotalSpent       Float?
  minVisits           Int?
  minMonthlySpent     Float?
  
  // Tier Benefits
  cashbackMultiplier  Float @default(1.0) // 1.5 = 50% bonus cashback
  discountPercentage  Float @default(0)
  priorityBooking     Boolean @default(false)
  exclusiveServices   Boolean @default(false)
  
  // Display order
  order Int @default(0)
  
  program  LoyaltyProgram         @relation(fields: [programId], references: [id], onDelete: Cascade)
  clients  ClientLoyaltyBalance[]
  
  @@index([programId])
  @@index([minTotalSpent])
}

// Client Loyalty Balance
model ClientLoyaltyBalance {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  clientId  String
  salonId   String
  programId String
  
  // Current Balance
  availableBalance Float @default(0)
  pendingBalance   Float @default(0) // Cashback waiting confirmation
  lifetimeEarned   Float @default(0)
  lifetimeRedeemed Float @default(0)
  
  // VIP Tier
  currentTierId    String?
  tierAchievedAt   DateTime?
  
  // Statistics for tier calculation
  totalSpent       Float    @default(0)
  totalVisits      Int      @default(0)
  lastActivityAt   DateTime @default(now())
  
  client  Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  salon   Salon           @relation(fields: [salonId], references: [id], onDelete: Cascade)
  program LoyaltyProgram  @relation(fields: [programId], references: [id], onDelete: Cascade)
  tier    LoyaltyTier?    @relation(fields: [currentTierId], references: [id], onDelete: SetNull)
  transactions LoyaltyTransaction[]
  
  @@unique([clientId, programId])
  @@index([salonId])
  @@index([programId])
  @@index([currentTierId])
}

// Loyalty Transaction History
model LoyaltyTransaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  
  balanceId String
  programId String
  salonId   String
  clientId  String
  
  type              LoyaltyTransactionType
  amount            Float
  balanceAfter      Float
  
  description       String?
  
  // Related entities
  saleId            String? // If earned from sale
  redemptionSaleId  String? // If redeemed in sale
  
  expiresAt         DateTime?
  expiredAt         DateTime?
  
  metadata          Json? // Additional data
  
  balance ClientLoyaltyBalance @relation(fields: [balanceId], references: [id], onDelete: Cascade)
  program LoyaltyProgram       @relation(fields: [programId], references: [id], onDelete: Cascade)
  salon   Salon                @relation(fields: [salonId], references: [id], onDelete: Cascade)
  client  Client               @relation(fields: [clientId], references: [id], onDelete: Cascade)
  
  @@index([balanceId, createdAt])
  @@index([clientId, createdAt])
  @@index([salonId, type])
  @@index([expiresAt])
}

enum LoyaltyTransactionType {
  EARNED            // Cashback earned from purchase
  REDEEMED          // Cashback redeemed
  EXPIRED           // Cashback expired
  ADJUSTED          // Manual adjustment
  BONUS             // Promotional bonus
  REFUNDED          // Refund from cancelled sale
  TIER_BONUS        // VIP tier bonus
}

// ============================================================================
// Referral Program Models
// ============================================================================

// Referral Program Configuration
model ReferralProgram {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  salonId String
  
  name        String
  description String? @db.Text
  isActive    Boolean @default(true)
  
  // Referrer Rewards (who refers)
  referrerRewardType    ReferralRewardType
  referrerRewardValue   Float // Amount or percentage
  referrerRewardDelay   Int @default(0) // Days to wait before giving reward
  
  // Referee Rewards (who was referred)
  refereeRewardType     ReferralRewardType
  refereeRewardValue    Float
  refereeRewardOnFirstVisit Boolean @default(true)
  
  // Qualification Rules
  minPurchaseAmount     Float? // Minimum referee purchase to qualify
  maxRewardPerReferrer  Float? // Max total rewards per referrer
  expiryDays            Int? // Days until referral expires
  
  // Tracking
  requireFirstVisit     Boolean @default(true)
  trackingCookie        Boolean @default(true)
  
  deletedAt DateTime?
  
  salon     Salon      @relation(fields: [salonId], references: [id], onDelete: Cascade)
  referrals Referral[]
  
  @@index([salonId, isActive])
}

enum ReferralRewardType {
  CASHBACK         // Add to loyalty balance
  DISCOUNT_PERCENT // Percentage discount on next purchase
  DISCOUNT_FIXED   // Fixed amount discount
  FREE_SERVICE     // Free service credit
  POINTS           // Loyalty points
}

// Referral Tracking
model Referral {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  programId   String
  salonId     String
  
  // Referrer (existing client)
  referrerId  String
  referrerCode String @unique // e.g., "MARIA2024"
  
  // Referee (new client)
  refereeId   String?
  refereeName String? // Name before client created
  refereePhone String?
  refereeEmail String?
  
  // Status Tracking
  status      ReferralStatus @default(PENDING)
  
  // Qualification Tracking
  sharedAt      DateTime  @default(now())
  sharedVia     ReferralChannel?
  clickedAt     DateTime?
  signedUpAt    DateTime?
  firstVisitAt  DateTime?
  qualifiedAt   DateTime?
  
  // Rewards
  referrerRewardIssued    Boolean @default(false)
  referrerRewardIssuedAt  DateTime?
  referrerRewardAmount    Float?
  
  refereeRewardIssued     Boolean @default(false)
  refereeRewardIssuedAt   DateTime?
  refereeRewardAmount     Float?
  
  // Expiry
  expiresAt    DateTime?
  
  metadata     Json? // Additional tracking data
  
  program  ReferralProgram @relation(fields: [programId], references: [id], onDelete: Cascade)
  salon    Salon           @relation(fields: [salonId], references: [id], onDelete: Cascade)
  referrer Client          @relation("Referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referee  Client?         @relation("Referee", fields: [refereeId], references: [id], onDelete: Cascade)
  
  @@index([salonId, status])
  @@index([referrerId])
  @@index([refereeId])
  @@index([referrerCode])
  @@index([qualifiedAt])
}

enum ReferralStatus {
  PENDING       // Referral shared, waiting for signup
  CLICKED       // Link clicked
  SIGNED_UP     // Referee created account
  FIRST_VISIT   // Referee completed first visit
  QUALIFIED     // Referral qualified for rewards
  REWARDED      // Rewards issued
  EXPIRED       // Referral expired
  CANCELLED     // Referral cancelled
}

enum ReferralChannel {
  WHATSAPP
  EMAIL
  SMS
  LINK
  QR_CODE
  IN_PERSON
}

// ============================================================================
// Photo Management Models
// ============================================================================

// Client Photos
model ClientPhoto {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  clientId String
  salonId  String
  uploadedBy String
  
  // File Information
  fileUrl      String
  thumbnailUrl String?
  fileName     String
  fileSize     Int // bytes
  mimeType     String
  width        Int?
  height       Int?
  
  // Photo Classification
  photoType    PhotoType @default(GENERAL)
  category     String? // Hair, Nails, Makeup, etc.
  
  // Before/After Grouping
  isBeforeAfter    Boolean @default(false)
  beforeAfterPairId String? // Links before & after photos
  position         PhotoPosition?
  
  // Metadata
  title        String?
  description  String? @db.Text
  tags         String[] // searchable tags
  takenAt      DateTime? // When photo was taken (vs uploaded)
  
  // Related Entities
  appointmentId String? // Photo taken during appointment
  serviceIds    String[] // Services shown in photo
  
  // Visibility & Permissions
  isPublic     Boolean @default(false) // Can be shown in portfolio
  showInGallery Boolean @default(true)
  clientApproved Boolean @default(false) // Client approved for public use
  
  // AI Analysis (Future enhancement)
  aiTags       String[]
  aiDescription String?
  
  deletedAt DateTime?
  
  client       Client       @relation(fields: [clientId], references: [id], onDelete: Cascade)
  salon        Salon        @relation(fields: [salonId], references: [id], onDelete: Cascade)
  uploader     User         @relation("PhotoUploader", fields: [uploadedBy], references: [id], onDelete: Restrict)
  appointment  Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)
  
  @@index([clientId, createdAt])
  @@index([salonId, photoType])
  @@index([beforeAfterPairId])
  @@index([appointmentId])
  @@index([isPublic, clientApproved])
}

enum PhotoType {
  GENERAL
  BEFORE
  AFTER
  PROGRESS
  PORTFOLIO
  RESULT
}

enum PhotoPosition {
  BEFORE
  AFTER
}

// ============================================================================
// Anamnesis System Models
// ============================================================================

// Anamnesis Form Template
model AnamnesisForm {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  salonId String
  createdBy String
  
  name        String
  description String? @db.Text
  
  // Form Configuration
  formData    Json // Form structure (fields, sections, validations)
  version     Int  @default(1)
  
  // Usage Settings
  isActive    Boolean @default(true)
  isDefault   Boolean @default(false)
  isTemplate  Boolean @default(false) // System template
  
  // Requirements
  requireSignature       Boolean @default(true)
  requireWitnessSignature Boolean @default(false)
  
  // Categories this form applies to
  serviceCategories String[] // Which services require this form
  
  usageCount  Int @default(0)
  
  deletedAt DateTime?
  
  salon       Salon             @relation(fields: [salonId], references: [id], onDelete: Cascade)
  creator     User              @relation("AnamnesisFormCreator", fields: [createdBy], references: [id], onDelete: Restrict)
  submissions ClientAnamnesis[]
  
  @@index([salonId, isActive])
  @@index([isDefault])
}

// Client Anamnesis Submission
model ClientAnamnesis {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  clientId  String
  salonId   String
  formId    String
  filledBy  String? // User who helped fill (if staff-assisted)
  
  // Form Data
  formData  Json // Filled form data
  
  // Signatures
  clientSignature         String? // Base64 or URL
  clientSignedAt          DateTime?
  
  witnessSignature        String?
  witnessName             String?
  witnessSignedAt         DateTime?
  
  staffSignature          String?
  staffName               String?
  staffSignedAt           DateTime?
  
  // Status
  status                  AnamnesisStatus @default(DRAFT)
  completedAt             DateTime?
  
  // Version tracking
  version                 Int @default(1)
  previousVersionId       String?
  
  // Related
  appointmentId           String? // If filled for specific appointment
  
  // Export
  pdfUrl                  String? // Generated PDF URL
  pdfGeneratedAt          DateTime?
  
  // LGPD Compliance
  dataRetentionDate       DateTime? // When data should be deleted
  
  deletedAt DateTime?
  
  client      Client       @relation(fields: [clientId], references: [id], onDelete: Cascade)
  salon       Salon        @relation(fields: [salonId], references: [id], onDelete: Cascade)
  form        AnamnesisForm @relation(fields: [formId], references: [id], onDelete: Restrict)
  filler      User?        @relation("AnamnesisFilledBy", fields: [filledBy], references: [id], onDelete: SetNull)
  appointment Appointment? @relation(fields: [appointmentId], references: [id], onDelete: SetNull)
  
  @@index([clientId, createdAt])
  @@index([salonId, status])
  @@index([formId])
  @@index([appointmentId])
}

enum AnamnesisStatus {
  DRAFT
  COMPLETED
  SIGNED
  ARCHIVED
  EXPIRED
}

// ============================================================================
// Advanced Analytics Models
// ============================================================================

// Client Lifetime Value Calculation Cache
model ClientMetrics {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  clientId String @unique
  salonId  String
  
  // Lifetime Value (CLV)
  lifetimeValue       Float @default(0)
  predictedLTV        Float @default(0)
  avgTransactionValue Float @default(0)
  
  // Visit Metrics
  totalVisits         Int @default(0)
  visitFrequency      Float @default(0) // Visits per month
  daysSinceLastVisit  Int @default(0)
  avgDaysBetweenVisits Float @default(0)
  
  // Spending Metrics
  totalSpent          Float @default(0)
  avgMonthlySpending  Float @default(0)
  lastPurchaseAmount  Float @default(0)
  
  // Engagement Metrics
  appointmentShowRate    Float @default(100) // Percentage
  cancellationRate       Float @default(0)
  rescheduleRate         Float @default(0)
  
  // Retention Metrics
  retentionStatus        RetentionStatus @default(NEW)
  churnRisk             Float @default(0) // 0-100 score
  churnReasonPredicted  String?
  
  // Cohort Information
  cohortMonth           String? // YYYY-MM of first visit
  monthsSinceFirstVisit Int @default(0)
  
  // Preferences
  preferredServices     String[] // Service IDs
  preferredProfessional String? // User ID
  preferredDayOfWeek    Int?
  preferredTimeOfDay    String? // MORNING, AFTERNOON, EVENING
  
  // Scores
  satisfactionScore     Float? // 0-10
  loyaltyScore          Float? // 0-100
  referralScore         Float? // 0-100 (likelihood to refer)
  
  // Flags
  isVIP                 Boolean @default(false)
  isAtRisk              Boolean @default(false)
  needsAttention        Boolean @default(false)
  
  lastCalculatedAt      DateTime @default(now())
  
  client Client @relation(fields: [clientId], references: [id], onDelete: Cascade)
  salon  Salon  @relation(fields: [salonId], references: [id], onDelete: Cascade)
  
  @@index([salonId, churnRisk])
  @@index([salonId, lifetimeValue])
  @@index([salonId, retentionStatus])
  @@index([isAtRisk])
}

enum RetentionStatus {
  NEW           // 0-30 days
  ACTIVE        // Regular visits
  AT_RISK       // Longer than usual since last visit
  DORMANT       // 90+ days
  CHURNED       // 180+ days
  REACTIVATED   // Returned after being dormant
}

// Salon-wide Analytics Snapshots
model SalonAnalytics {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  
  salonId String
  date    DateTime @default(now())
  period  AnalyticsPeriod
  
  // Client Metrics
  totalClients           Int @default(0)
  activeClients          Int @default(0)
  newClients             Int @default(0)
  churnedClients         Int @default(0)
  reactivatedClients     Int @default(0)
  
  // Revenue Metrics
  totalRevenue           Float @default(0)
  avgTransactionValue    Float @default(0)
  avgClientLTV           Float @default(0)
  
  // Visit Metrics
  totalAppointments      Int @default(0)
  completedAppointments  Int @default(0)
  cancelledAppointments  Int @default(0)
  noShowAppointments     Int @default(0)
  
  // Retention Metrics
  retentionRate          Float @default(0)
  churnRate              Float @default(0)
  repeatClientRate       Float @default(0)
  
  // Cohort Data
  cohortData             Json? // Cohort analysis data
  
  // Top Performers
  topServices            Json? // Most popular services
  topProfessionals       Json? // Best performing staff
  topClients             Json? // Highest value clients
  
  salon Salon @relation(fields: [salonId], references: [id], onDelete: Cascade)
  
  @@unique([salonId, date, period])
  @@index([salonId, period, date])
}

enum AnalyticsPeriod {
  DAILY
  WEEKLY
  MONTHLY
  QUARTERLY
  YEARLY
}
